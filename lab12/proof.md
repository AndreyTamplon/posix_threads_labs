Докажем от противного. Пусть возможно синхронизовать два потока двумя мьютексами.

$T_1$ - родительский поток, печатает первым, $T_2$ - дочерний поток, $M_1$ и $M_2$ - первый и второй мьютекс соответственно. При инициализации $T_1$ берет $M_1$ и ждёт, чтобы $T_2$ заблокировался в $M_1$. Сделать, чтобы $T_1$ написал первым можно и иначе, но ситуация, когда один поток держит мьютекс, а второй заблокирован в нём всё равно возникнет в этой задаче, поэтому можно начать и с этого этапа. Теперь $T_1$ делает $print$ и должен будет заблокироваться, чтобы $T_2$ сделал свой $print$. $T_1$ может заблокироваться только на $M_2$ (иначе будет deadlock ($T_1$ на $M_1$ и $T_2$ на $M_1$)). До разблокировки $M_1$, он это сделать не может, потому что произойдёт deadlock ($T_1$ на $M_2$ и $T_2$ на $M_1$). $T_1$ разблокирует $M_1$, и не может на нём заблокироваться т.к. не ясно кто из потоков возьмёт $M_1$ первым. $T_2$ взял $M_1$. $T_1$ блокируется на $M_2$, который $T_2$ взял изначально, потому что иначе сейчас возникло бы состояние гонки за $M_2$. $T_2$ делает свой $print$ не важно до или после предыдущего шага. Теперь у нас ситуация в которой $T_2$ держит два мьютекса, а $T_1$ заблокирован на $M_2$. Чтобы $T_1$ написал свой $print$, он должен быть разблокирован, а $T_2$ должен заблокироваться. 

Допустим $T_2$ будет блокироваться на $M_1$. Тогда после освобождения $M_2$ и $M_1$ возникнет гонка за $M_1$, потому что $T_1$ будет необходимо его взять, чтобы $T_2$ в нём заблокировался. Если $T_2$ будет блокироваться на $M_2$, то возникнет гонка с $T_1$, который был заблокирован в $M_2$ и теперь тоже попытается его взять после разблокировки $M_2$. 

Таким образом, при двух мьютексах будут возникать ситуации при которых будет вероятность, что один поток напишет дважды.
